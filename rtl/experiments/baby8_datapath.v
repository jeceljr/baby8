/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// This simple circuit can do all the operations needed to execute Baby8 instructions
module baby8_datapath (
  input clock, // all registers store their inputs (when enabled) at the rising edge of this signal
  input [7:0] in0, // input port at address 0
  input [7:0] in1, // input port at address 1
  input wReg, // allow register selected by adW to receive the value from R
  input [3:0] wAd, // register to be written
  input [3:0] aAd, // register to use for A
  input [3:0] bAd, // register to use for B
  input [7:0] dIn, // value read from main memory
  input [1:0] bSel, // select register, memory or input port for B
  input [1:0] logSel, // select logical operation between A and B or just use B
  input [1:0] aSel, // select A, inverted A or a constant to be added
  input Cin, // carry in
  input A7, // replacement for A7
  input A0, // replacement for A0
  input a7S, // use original A7 or replacement
  input a0S, // use original A0 or replacement
  output [7:0] R, // result of the addition
  output [7:0] dOut, // result of the addition in the previous cycle - used as data to be written to main memory
  output [15:0] address, // address for main memory
  output Z, // addition had zero result
  output C, // carry out
  output N, // addition had negative result
  output V // addition overflowed

);
  wire [7:0] R_temp;
  wire [7:0] s0;
  wire [7:0] s1;
  wire [7:0] s2;
  wire [7:0] s3;
  wire [7:0] s4;
  wire [7:0] s5;
  wire [7:0] s6;
  wire [7:0] s7;
  wire [7:0] s8;
  wire [7:0] s9;
  wire [7:0] s10;
  wire [7:0] s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire N_temp;
  // registers
  DIG_RegisterFile #(
    .Bits(8),
    .AddrBits(4)
  )
  DIG_RegisterFile_i0 (
    .Din( R_temp ),
    .we( wReg ),
    .Rw( wAd ),
    .C( clock ),
    .Ra( aAd ),
    .Rb( bAd ),
    .Da( s0 ),
    .Db( s1 )
  );
  DIG_Add #(
    .Bits(8)
  )
  DIG_Add_i1 (
    .a( s2 ),
    .b( s3 ),
    .c_i( Cin ),
    .s( s4 ),
    .c_o( C )
  );
  Mux_4x1_NBits #(
    .Bits(8)
  )
  Mux_4x1_NBits_i2 (
    .sel( aSel ),
    .in_0( s0 ),
    .in_1( s5 ),
    .in_2( 8'b0 ),
    .in_3( 8'b11111110 ),
    .out( s6 )
  );
  Mux_4x1_NBits #(
    .Bits(8)
  )
  Mux_4x1_NBits_i3 (
    .sel( logSel ),
    .in_0( s7 ),
    .in_1( s8 ),
    .in_2( s9 ),
    .in_3( s10 ),
    .out( s11 )
  );
  Mux_4x1_NBits #(
    .Bits(8)
  )
  Mux_4x1_NBits_i4 (
    .sel( bSel ),
    .in_0( s1 ),
    .in_1( dIn ),
    .in_2( in0 ),
    .in_3( in1 ),
    .out( s10 )
  );
  // prevR
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i5 (
    .D( R_temp ),
    .C( clock ),
    .en( 1'b1 ),
    .Q( dOut )
  );
  Mux_2x1 Mux_2x1_i6 (
    .sel( a7S ),
    .in_0( s12 ),
    .in_1( A7 ),
    .out( s13 )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( a0S ),
    .in_0( s14 ),
    .in_1( A0 ),
    .out( s15 )
  );
  assign s7 = (s0 & s10);
  assign s8 = (s0 | s10);
  assign s9 = (s0 ^ s10);
  assign s5 = ~ s0;
  assign address[0] = s15;
  assign address[6:1] = s1[6:1];
  assign address[7] = s13;
  assign address[15:8] = s0;
  assign s14 = s1[0];
  assign s12 = s1[7];
  assign s16 = s6[7];
  assign s17 = s11[7];
  assign N_temp = s4[7];
  assign s2[6:0] = s6[6:0];
  assign s2[7] = s16;
  assign s3[6:0] = s11[6:0];
  assign s3[7] = s17;
  assign R_temp[6:0] = s4[6:0];
  assign R_temp[7] = N_temp;
  assign V = ((N_temp & ~ s16 & ~ s17) | (~ N_temp & s16 & s17));
  assign Z = ~ (R_temp[0] | R_temp[1] | R_temp[2] | R_temp[3] | R_temp[4] | R_temp[5] | R_temp[6] | R_temp[7]);
  assign R = R_temp;
  assign N = N_temp;
endmodule
